package net.seabears;

/** A point is two-dimensional space */
public class Point implements Comparable<Point> {
  /** Returns the Point from the string (reverse of {@link #toString}) */
  public static Point fromString(String s) {
    // not the smartest way to parse points, but it will work for points generated by this program
    final String[] coords = s.trim().split("\\s+");
    return new Point(Double.parseDouble(coords[0]), Double.parseDouble(coords[1]));
  }

  public final double x;
  public final double y;

  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

  /**
   * Returns counter-clockwiseness of the two points with this point. The turn
   * is counter-clockwise if the return value is > 0. The points are collinear
   * if the return value is 0.
   */
  public double ccw(Point a, Point b) {
    return (a.x - x) * (b.y - y) - (a.y - y) * (b.x - x);
  }

  /** Returns the distance (multiplied by itself) from this point to the specified point. */
  public double distanceSquared(Point o) {
    return Math.pow(o.x - x, 2) + Math.pow(o.y - y, 2);
  }

  @Override
  public int compareTo(Point o) {
    int res = Double.compare(y, o.y);
    return res != 0 ? res : Double.compare(x, o.x);
  }

  @Override
  public String toString() {
    return x + " " + y;
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = Double.doubleToLongBits(x);
    result = prime * result + (int) (temp ^ (temp >>> 32));
    temp = Double.doubleToLongBits(y);
    result = prime * result + (int) (temp ^ (temp >>> 32));
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }

    final Point other = (Point) obj;
    return Double.doubleToLongBits(x) == Double.doubleToLongBits(other.x)
        && Double.doubleToLongBits(y) == Double.doubleToLongBits(other.y);
  }
}
